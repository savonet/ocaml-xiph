<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ogg_decoder (ogg.Ogg_decoder)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.4"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">ogg</a> &#x00BB; Ogg_decoder</nav><header class="odoc-preamble"><h1>Module <code><span>Ogg_decoder</span></code></h1><p>Ogg stream demuxer</p></header><nav class="odoc-toc"><ul><li><a href="#decoding">Decoding</a><ul><li><a href="#types">Types</a></li><li><a href="#exceptions">Exceptions</a></li><li><a href="#initialization-functions">Initialization functions</a></li><li><a href="#information-functions">Information functions</a></li><li><a href="#seeking-functions">Seeking functions</a></li><li><a href="#decoding-functions">Decoding functions</a></li></ul></li><li><a href="#implementing-decoders">Implementing decoders</a><ul><li><a href="#types_2">Types</a></li><li><a href="#functions">Functions</a></li></ul></li></ul></nav><div class="odoc-content"><p>This module provides a functional abstract API to * decode and seek in Ogg streams. * * Decoders are also provided in ocaml-vorbis, * ocaml-speex, ocaml-schroedinger, ocaml-flac and * ocaml-theora. * * Functions in this module are not thread safe!</p><h3 id="decoding"><a href="#decoding" class="anchor"></a>Decoding</h3><h4 id="types"><a href="#types" class="anchor"></a>Types</h4><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>Type of an ogg stream decoder.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-callbacks"><a href="#type-callbacks" class="anchor"></a><code><span><span class="keyword">type</span> callbacks</span><span> = </span><span>{</span></code><ol><li id="type-callbacks.read" class="def record field anchored"><a href="#type-callbacks.read" class="anchor"></a><code><span>read : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int;</span></code></li><li id="type-callbacks.seek" class="def record field anchored"><a href="#type-callbacks.seek" class="anchor"></a><code><span>seek : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> int)</span> option</span>;</span></code></li><li id="type-callbacks.tell" class="def record field anchored"><a href="#type-callbacks.tell" class="anchor"></a><code><span>tell : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> int)</span> option</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Type for callbacks used to acess encoded data.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-track"><a href="#type-track" class="anchor"></a><code><span><span class="keyword">type</span> track</span><span> = </span></code><ol><li id="type-track.Audio_track" class="def variant constructor anchored"><a href="#type-track.Audio_track" class="anchor"></a><code><span>| </span><span><span class="constructor">Audio_track</span> <span class="keyword">of</span> string * nativeint</span></code></li><li id="type-track.Video_track" class="def variant constructor anchored"><a href="#type-track.Video_track" class="anchor"></a><code><span>| </span><span><span class="constructor">Video_track</span> <span class="keyword">of</span> string * nativeint</span></code></li></ol></div><div class="spec-doc"><p>Type for a decodable track. * First element is a string describing * the decoder used to decode the track. * Second element is the serial number * associated to the <code>Ogg.Stream.stream</code> logical * stream used to pull data packets for that * track.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-standard_tracks"><a href="#type-standard_tracks" class="anchor"></a><code><span><span class="keyword">type</span> standard_tracks</span><span> = </span><span>{</span></code><ol><li id="type-standard_tracks.audio_track" class="def record field anchored"><a href="#type-standard_tracks.audio_track" class="anchor"></a><code><span><span class="keyword">mutable</span> audio_track : <span><a href="#type-track">track</a> option</span>;</span></code></li><li id="type-standard_tracks.video_track" class="def record field anchored"><a href="#type-standard_tracks.video_track" class="anchor"></a><code><span><span class="keyword">mutable</span> video_track : <span><a href="#type-track">track</a> option</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Type for standard tracks (see <code>get_standard_tracks</code> below).</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-metadata"><a href="#type-metadata" class="anchor"></a><code><span><span class="keyword">type</span> metadata</span><span> = string * <span><span>(string * string)</span> list</span></span></code></div><div class="spec-doc"><p>Type for metadata. First element * is a string describing the vendor, second * element is a list of metadata of the form: * <code>(label,value)</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-audio_info"><a href="#type-audio_info" class="anchor"></a><code><span><span class="keyword">type</span> audio_info</span><span> = </span><span>{</span></code><ol><li id="type-audio_info.channels" class="def record field anchored"><a href="#type-audio_info.channels" class="anchor"></a><code><span>channels : int;</span></code></li><li id="type-audio_info.sample_rate" class="def record field anchored"><a href="#type-audio_info.sample_rate" class="anchor"></a><code><span>sample_rate : int;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Type for audio information.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-audio_data"><a href="#type-audio_data" class="anchor"></a><code><span><span class="keyword">type</span> audio_data</span><span> = <span><span>float array</span> array</span></span></code></div><div class="spec-doc"><p>Type for audio data.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-audio_ba_data"><a href="#type-audio_ba_data" class="anchor"></a><code><span><span class="keyword">type</span> audio_ba_data</span><span> =
  <span><span><span>(float, <span class="xref-unresolved">Stdlib</span>.Bigarray.float32_elt, <span class="xref-unresolved">Stdlib</span>.Bigarray.c_layout)</span>
    <span class="xref-unresolved">Stdlib</span>.Bigarray.Array1.t</span>
    array</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-video_plane"><a href="#type-video_plane" class="anchor"></a><code><span><span class="keyword">type</span> video_plane</span><span> =
  <span><span>(int, <span class="xref-unresolved">Stdlib</span>.Bigarray.int8_unsigned_elt, <span class="xref-unresolved">Stdlib</span>.Bigarray.c_layout)</span>
    <span class="xref-unresolved">Stdlib</span>.Bigarray.Array1.t</span></span></code></div><div class="spec-doc"><p>Type of a video plane.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-video_format"><a href="#type-video_format" class="anchor"></a><code><span><span class="keyword">type</span> video_format</span><span> = </span></code><ol><li id="type-video_format.Yuvj_420" class="def variant constructor anchored"><a href="#type-video_format.Yuvj_420" class="anchor"></a><code><span>| </span><span><span class="constructor">Yuvj_420</span></span></code></li><li id="type-video_format.Yuvj_422" class="def variant constructor anchored"><a href="#type-video_format.Yuvj_422" class="anchor"></a><code><span>| </span><span><span class="constructor">Yuvj_422</span></span></code></li><li id="type-video_format.Yuvj_444" class="def variant constructor anchored"><a href="#type-video_format.Yuvj_444" class="anchor"></a><code><span>| </span><span><span class="constructor">Yuvj_444</span></span></code></li></ol></div><div class="spec-doc"><p>Supported video formats.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-video_info"><a href="#type-video_info" class="anchor"></a><code><span><span class="keyword">type</span> video_info</span><span> = </span><span>{</span></code><ol><li id="type-video_info.fps_numerator" class="def record field anchored"><a href="#type-video_info.fps_numerator" class="anchor"></a><code><span>fps_numerator : int;</span></code></li><li id="type-video_info.fps_denominator" class="def record field anchored"><a href="#type-video_info.fps_denominator" class="anchor"></a><code><span>fps_denominator : int;</span></code></li><li id="type-video_info.width" class="def record field anchored"><a href="#type-video_info.width" class="anchor"></a><code><span>width : int;</span></code></li><li id="type-video_info.height" class="def record field anchored"><a href="#type-video_info.height" class="anchor"></a><code><span>height : int;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-video_data"><a href="#type-video_data" class="anchor"></a><code><span><span class="keyword">type</span> video_data</span><span> = </span><span>{</span></code><ol><li id="type-video_data.format" class="def record field anchored"><a href="#type-video_data.format" class="anchor"></a><code><span>format : <a href="#type-video_format">video_format</a>;</span></code></li><li id="type-video_data.frame_width" class="def record field anchored"><a href="#type-video_data.frame_width" class="anchor"></a><code><span>frame_width : int;</span></code></li><li id="type-video_data.frame_height" class="def record field anchored"><a href="#type-video_data.frame_height" class="anchor"></a><code><span>frame_height : int;</span></code></li><li id="type-video_data.y_stride" class="def record field anchored"><a href="#type-video_data.y_stride" class="anchor"></a><code><span>y_stride : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Length, in bytes, per line</p><span class="comment-delim">*)</span></div></li><li id="type-video_data.uv_stride" class="def record field anchored"><a href="#type-video_data.uv_stride" class="anchor"></a><code><span>uv_stride : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Length, in bytes, per line</p><span class="comment-delim">*)</span></div></li><li id="type-video_data.y" class="def record field anchored"><a href="#type-video_data.y" class="anchor"></a><code><span>y : <a href="#type-video_plane">video_plane</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>luminance data</p><span class="comment-delim">*)</span></div></li><li id="type-video_data.u" class="def record field anchored"><a href="#type-video_data.u" class="anchor"></a><code><span>u : <a href="#type-video_plane">video_plane</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Cb data</p><span class="comment-delim">*)</span></div></li><li id="type-video_data.v" class="def record field anchored"><a href="#type-video_data.v" class="anchor"></a><code><span>v : <a href="#type-video_plane">video_plane</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Cr data</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Type for video data.</p></div></div><h4 id="exceptions"><a href="#exceptions" class="anchor"></a>Exceptions</h4><div class="odoc-spec"><div class="spec exception anchored" id="exception-Invalid_stream"><a href="#exception-Invalid_stream" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Invalid_stream</span></span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Not_available"><a href="#exception-Not_available" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Not_available</span></span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-End_of_stream"><a href="#exception-End_of_stream" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">End_of_stream</span></span></code></div></div><h4 id="initialization-functions"><a href="#initialization-functions" class="anchor"></a>Initialization functions</h4><div class="odoc-spec"><div class="spec value anchored" id="val-init"><a href="#val-init" class="anchor"></a><code><span><span class="keyword">val</span> init : <span><span class="optlabel">?log</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-callbacks">callbacks</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Initiate a decoder with the given callbacks. * <code>log</code> is an optional functioned used to * return logged messages during the deocding * process.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-init_from_file"><a href="#val-init_from_file" class="anchor"></a><code><span><span class="keyword">val</span> init_from_file : <span><span class="optlabel">?log</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a> * <span class="xref-unresolved">Unix</span>.file_descr</span></code></div><div class="spec-doc"><p>Initiate a decoder from a given file name.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-init_from_fd"><a href="#val-init_from_fd" class="anchor"></a><code><span><span class="keyword">val</span> init_from_fd : <span><span class="optlabel">?log</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Unix</span>.file_descr <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Initate a decoder from a given <code>Unix.file_descriptor</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_ogg_sync"><a href="#val-get_ogg_sync" class="anchor"></a><code><span><span class="keyword">val</span> get_ogg_sync : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Ogg/Sync/index.html#type-t">Ogg.Sync.t</a></span></code></div><div class="spec-doc"><p>Get the Ogg.Sync handler associated to * the decoder. Use only if know what you are doing.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-reset"><a href="#val-reset" class="anchor"></a><code><span><span class="keyword">val</span> reset : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Reset encoder, try to parse a new sequentialized stream. * To use when end_of_stream has been reached.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-abort"><a href="#val-abort" class="anchor"></a><code><span><span class="keyword">val</span> abort : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Consume all remaining pages of the current * stream. This function may be called to skip * a sequentialized stream but it may be quite * CPU intensive if there are many pages remaining.. * * <code>eos dec</code> is <code>true</code> after this call.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eos"><a href="#val-eos" class="anchor"></a><code><span><span class="keyword">val</span> eos : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>true</code> if the decoder has reached the end of each * logical streams and all data has been decoded. * * If you do not plan on decoding some data, * you should use <code>drop_track</code> to indicate it * to the decoder. Otherwise, <code>eos</code> will return * <code>false</code> until you have decoded all data.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_tracks"><a href="#val-get_tracks" class="anchor"></a><code><span><span class="keyword">val</span> get_tracks : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-track">track</a> list</span></span></code></div><div class="spec-doc"><p>Get all decodable tracks available.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_standard_tracks"><a href="#val-get_standard_tracks" class="anchor"></a><code><span><span class="keyword">val</span> get_standard_tracks : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-standard_tracks">standard_tracks</a></span></code></div><div class="spec-doc"><p>Get the first available audio and * video tracks and drop the other one.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update_standard_tracks"><a href="#val-update_standard_tracks" class="anchor"></a><code><span><span class="keyword">val</span> update_standard_tracks : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-standard_tracks">standard_tracks</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Update a given record of standard tracks. You should * use this after a <code>reset</code> to update the standard tracks * with the newly created tracks.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-drop_track"><a href="#val-drop_track" class="anchor"></a><code><span><span class="keyword">val</span> drop_track : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-track">track</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Remove all tracks of the given type.</p></div></div><h4 id="information-functions"><a href="#information-functions" class="anchor"></a>Information functions</h4><div class="odoc-spec"><div class="spec value anchored" id="val-audio_info"><a href="#val-audio_info" class="anchor"></a><code><span><span class="keyword">val</span> audio_info : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-track">track</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-audio_info">audio_info</a> * <a href="#type-metadata">metadata</a></span></code></div><div class="spec-doc"><p>Get informations about the * audio track.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-can_decode_ba"><a href="#val-can_decode_ba" class="anchor"></a><code><span><span class="keyword">val</span> can_decode_ba : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-track">track</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>true</code> if the decoder can decoder to bigarray data.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-video_info"><a href="#val-video_info" class="anchor"></a><code><span><span class="keyword">val</span> video_info : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-track">track</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-video_info">video_info</a> * <a href="#type-metadata">metadata</a></span></code></div><div class="spec-doc"><p>Get informations about the * video track.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sample_rate"><a href="#val-sample_rate" class="anchor"></a><code><span><span class="keyword">val</span> sample_rate : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-track">track</a> <span class="arrow">&#45;&gt;</span></span> int * int</span></code></div><div class="spec-doc"><p>Get the sample_rate of the track * of that type. Returns a pair <code>(numerator,denominator)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_track_position"><a href="#val-get_track_position" class="anchor"></a><code><span><span class="keyword">val</span> get_track_position : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-track">track</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>Get track absolute position.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_position"><a href="#val-get_position" class="anchor"></a><code><span><span class="keyword">val</span> get_position : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>Get absolute position in the stream.</p></div></div><h4 id="seeking-functions"><a href="#seeking-functions" class="anchor"></a>Seeking functions</h4><div class="odoc-spec"><div class="spec value anchored" id="val-can_seek"><a href="#val-can_seek" class="anchor"></a><code><span><span class="keyword">val</span> can_seek : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Returns <code>true</code> if the decoder * can be used with the <code>seek</code> function.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-seek"><a href="#val-seek" class="anchor"></a><code><span><span class="keyword">val</span> seek : <span><span class="optlabel">?relative</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>Seek to an absolute or relative position in seconds. * * Raises <code>Not_available</code> if seeking is * not possible. * * Raises <code>End_of_stream</code> if the end of * current stream has been reached while * seeking. You may call <code>reset</code> in this * situation to see if there is a new seqentialized * stream available. * * Returns the time actually reached, either in * relative time or absolute time.</p></div></div><h4 id="decoding-functions"><a href="#decoding-functions" class="anchor"></a>Decoding functions</h4><div class="odoc-spec"><div class="spec value anchored" id="val-decode_audio"><a href="#val-decode_audio" class="anchor"></a><code><span><span class="keyword">val</span> decode_audio : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-track">track</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="#type-audio_data">audio_data</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Decode audio data, if possible. * Decoded data is passed to the second argument. * * Raises <code>End_of_stream</code> if all stream have ended. * In this case, you can try <code>reset</code> to see if there is a * new sequentialized stream.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-decode_audio_ba"><a href="#val-decode_audio_ba" class="anchor"></a><code><span><span class="keyword">val</span> decode_audio_ba : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-track">track</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="#type-audio_ba_data">audio_ba_data</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Decode audio data, if possible. * Decoded data is passed to the second argument. * * Raises <code>End_of_stream</code> if all stream have ended. * In this case, you can try <code>reset</code> to see if there is a * new sequentialized stream.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-decode_video"><a href="#val-decode_video" class="anchor"></a><code><span><span class="keyword">val</span> decode_video : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-track">track</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="#type-video_data">video_data</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Decode video data, if possible. * Decoded data is passed to the second argument. * * Raises <code>End_of_stream</code> if all streams have ended. * In this case, you can try <code>reset</code> to see if there is a * new sequentialized stream.</p></div></div><h3 id="implementing-decoders"><a href="#implementing-decoders" class="anchor"></a>Implementing decoders</h3><h4 id="types_2"><a href="#types_2" class="anchor"></a>Types</h4><div class="odoc-spec"><div class="spec type anchored" id="type-decoder"><a href="#type-decoder" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) decoder</span></span><span> = </span><span>{</span></code><ol><li id="type-decoder.name" class="def record field anchored"><a href="#type-decoder.name" class="anchor"></a><code><span>name : string;</span></code></li><li id="type-decoder.info" class="def record field anchored"><a href="#type-decoder.info" class="anchor"></a><code><span>info : <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <a href="#type-metadata">metadata</a>;</span></code></li><li id="type-decoder.decode" class="def record field anchored"><a href="#type-decoder.decode" class="anchor"></a><code><span>decode : <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li><li id="type-decoder.restart" class="def record field anchored"><a href="#type-decoder.restart" class="anchor"></a><code><span>restart : <span><span class="label">fill</span>:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Ogg/Stream/index.html#type-stream">Ogg.Stream.stream</a> <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li><li id="type-decoder.samples_of_granulepos" class="def record field anchored"><a href="#type-decoder.samples_of_granulepos" class="anchor"></a><code><span>samples_of_granulepos : <span><span class="xref-unresolved">Stdlib</span>.Int64.t <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Stdlib</span>.Int64.t;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Generic type for a decoder.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-decoders"><a href="#type-decoders" class="anchor"></a><code><span><span class="keyword">type</span> decoders</span><span> = </span></code><ol><li id="type-decoders.Video" class="def variant constructor anchored"><a href="#type-decoders.Video" class="anchor"></a><code><span>| </span><span><span class="constructor">Video</span> <span class="keyword">of</span> <span><span>(<a href="#type-video_info">video_info</a>, <a href="#type-video_data">video_data</a>)</span> <a href="#type-decoder">decoder</a></span></span></code></li><li id="type-decoders.Audio" class="def variant constructor anchored"><a href="#type-decoders.Audio" class="anchor"></a><code><span>| </span><span><span class="constructor">Audio</span> <span class="keyword">of</span> <span><span>(<a href="#type-audio_info">audio_info</a>, <a href="#type-audio_data">audio_data</a>)</span> <a href="#type-decoder">decoder</a></span></span></code></li><li id="type-decoders.Audio_ba" class="def variant constructor anchored"><a href="#type-decoders.Audio_ba" class="anchor"></a><code><span>| </span><span><span class="constructor">Audio_ba</span> <span class="keyword">of</span> <span><span>(<a href="#type-audio_info">audio_info</a>, <a href="#type-audio_ba_data">audio_ba_data</a>)</span> <a href="#type-decoder">decoder</a></span></span></code></li><li id="type-decoders.Audio_both" class="def variant constructor anchored"><a href="#type-decoders.Audio_both" class="anchor"></a><code><span>| </span><span><span class="constructor">Audio_both</span> <span class="keyword">of</span> <span><span>(<a href="#type-audio_info">audio_info</a>, <a href="#type-audio_data">audio_data</a>)</span> <a href="#type-decoder">decoder</a></span>
  * <span><span>(<a href="#type-audio_info">audio_info</a>, <a href="#type-audio_ba_data">audio_ba_data</a>)</span> <a href="#type-decoder">decoder</a></span></span></code></li><li id="type-decoders.Unknown" class="def variant constructor anchored"><a href="#type-decoders.Unknown" class="anchor"></a><code><span>| </span><span><span class="constructor">Unknown</span></span></code></li></ol></div><div class="spec-doc"><p>Type for a generic logical stream decoder.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-register_decoder"><a href="#type-register_decoder" class="anchor"></a><code><span><span class="keyword">type</span> register_decoder</span><span> =
  <span>(<span><a href="../Ogg/Stream/index.html#type-packet">Ogg.Stream.packet</a> <span class="arrow">&#45;&gt;</span></span>
  bool)</span>
  * <span>(<span><span class="label">fill</span>:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Ogg/Stream/index.html#type-stream">Ogg.Stream.stream</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-decoders">decoders</a>)</span></span></code></div><div class="spec-doc"><p>Type used to register a new decoder. First * element is a function used to check if the initial <code>Ogg.Stream.packet</code> * of an <code>Ogg.Stream.stream</code> matches the format decodable by this decoder. * Second element is a function that instanciates the actual decoder * using the initial <code>Ogg.Stream.stream</code> used to pull data packets for the * decoder.</p></div></div><h4 id="functions"><a href="#functions" class="anchor"></a>Functions</h4><div class="odoc-spec"><div class="spec value anchored" id="val-ogg_decoders"><a href="#val-ogg_decoders" class="anchor"></a><code><span><span class="keyword">val</span> ogg_decoders : <span><span>(string, <a href="#type-register_decoder">register_decoder</a>)</span> <span class="xref-unresolved">Stdlib</span>.Hashtbl.t</span></span></code></div><div class="spec-doc"><p>Register a new decoder.</p></div></div></div></body></html>
