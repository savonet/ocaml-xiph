<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Page (ogg.Ogg.Page)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.4"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">ogg</a> &#x00BB; <a href="../index.html">Ogg</a> &#x00BB; Page</nav><header class="odoc-preamble"><h1>Module <code><span>Ogg.Page</span></code></h1><p>* The <code>page</code> struct encapsulates the data for an Ogg page. * * Ogg pages are the fundamental unit of framing and interleave in an ogg * bitstream. They are made up of packet segments of 255 bytes each. There can * be as many as 255 packet segments per page, for a maximum page size of a * little under 64 kB. This is not a practical limitation as the segments can be * joined across page boundaries allowing packets of arbitrary size. In practice * pages are usually around 4 kB.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = string * string</span></code></div><div class="spec-doc"><p>A page is a header and a body</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-serialno"><a href="#val-serialno" class="anchor"></a><code><span><span class="keyword">val</span> serialno : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> nativeint</span></code></div><div class="spec-doc"><p>* Returns the unique serial number for the logical bitstream of this page. * Each page contains the serial number for the logical bitstream that it belongs to.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eos"><a href="#val-eos" class="anchor"></a><code><span><span class="keyword">val</span> eos : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>* Indicates whether this page is at the end of the logical bitstream.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bos"><a href="#val-bos" class="anchor"></a><code><span><span class="keyword">val</span> bos : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>* Indicates whether this page is at the begining of the logical bitstream.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-continued"><a href="#val-continued" class="anchor"></a><code><span><span class="keyword">val</span> continued : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>* Indicates whether this page contains packet data which has been * continued from the previous page.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-packets"><a href="#val-packets" class="anchor"></a><code><span><span class="keyword">val</span> packets : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>* Returns the number of packets that are completed on this page. * If the leading packet is begun on a previous page, but ends on this page, it's counted. * * If a page consists of a packet begun on a previous page, and a new packet begun * (but not completed) on this page, the return will be: * * <code>packets page</code> will return <code>1</code>, * <code>continued paged</code> will return <code>true</code> * * If a page happens to be a single packet that was begun on a previous page, * and spans to the next page (in the case of a three or more page packet), the return will be: * * <code>packets page</code> will return 0, * <code>continued page</code> will return <code>true</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-version"><a href="#val-version" class="anchor"></a><code><span><span class="keyword">val</span> version : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>* This function returns the version of ogg_page used in this page. * In current versions of libogg, all ogg_page structs have the same version, * so <code>0</code> should always be returned.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-granulepos"><a href="#val-granulepos" class="anchor"></a><code><span><span class="keyword">val</span> granulepos : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Stdlib</span>.Int64.t</span></code></div><div class="spec-doc"><p>* Returns the exact granular position of the packet data contained at the end of this page. * * This is useful for tracking location when seeking or decoding. * * For example, in audio codecs this position is the pcm sample number and * in video this is the frame number.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pageno"><a href="#val-pageno" class="anchor"></a><code><span><span class="keyword">val</span> pageno : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> nativeint</span></code></div><div class="spec-doc"><p>* Returns the sequential page number. * * This is useful for ordering pages or determining when pages have been lost.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_checksum"><a href="#val-set_checksum" class="anchor"></a><code><span><span class="keyword">val</span> set_checksum : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>* Checksums an ogg_page.</p></div></div></div></body></html>
