<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Stream (ogg.Ogg.Stream)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.4"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">ogg</a> &#x00BB; <a href="../index.html">Ogg</a> &#x00BB; Stream</nav><header class="odoc-preamble"><h1>Module <code><span>Ogg.Stream</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-stream"><a href="#type-stream" class="anchor"></a><code><span><span class="keyword">type</span> stream</span></code></div><div class="spec-doc"><p>* The <code>stream</code> values track the current encode/decode state of the * current logical bitstream.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-packet"><a href="#type-packet" class="anchor"></a><code><span><span class="keyword">type</span> packet</span></code></div><div class="spec-doc"><p>* A data packet to pass to the decoder</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span><span class="optlabel">?serial</span>:nativeint <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-stream">stream</a></span></code></div><div class="spec-doc"><p>* Create a <code>stream</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-serialno"><a href="#val-serialno" class="anchor"></a><code><span><span class="keyword">val</span> serialno : <span><a href="#type-stream">stream</a> <span class="arrow">&#45;&gt;</span></span> nativeint</span></code></div><div class="spec-doc"><p>* Get a stream's serial number.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eos"><a href="#val-eos" class="anchor"></a><code><span><span class="keyword">val</span> eos : <span><a href="#type-stream">stream</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Returns true if the end of stream has been reached.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-terminate"><a href="#val-terminate" class="anchor"></a><code><span><span class="keyword">val</span> terminate : <span><a href="#type-stream">stream</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Page/index.html#type-t">Page.t</a> list</span></span></code></div><div class="spec-doc"><p>Terminate the stream and return its final pages.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_page"><a href="#val-get_page" class="anchor"></a><code><span><span class="keyword">val</span> get_page : <span><span class="optlabel">?fill</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-stream">stream</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Page/index.html#type-t">Page.t</a></span></code></div><div class="spec-doc"><p>* This function forms packets into pages. Internally, * it assembles the accumulated packet bodies into an Ogg page * suitable for writing to a stream. * * If no <code>fill</code> argument is passed, this function will only return * a page when a &quot;reasonable&quot; amount of packet data is available. * Normally this is appropriate since it limits the overhead of the * Ogg page headers in the bitstream. * * If a <code>fill</code> argument is passed, this function will return a page when at * least four packets have been accumulated and accumulated packet data meets * or exceeds the specified number of bytes, and/or when the accumulated * packet data meets/exceeds the maximum page size regardless of accumulated * packet count. * * The exception <code>Not_enough_data</code> is raised if not enough data is available * to generate the page. * * Call <code>flush_page</code> if immediate page generation is desired. This * may be occasionally necessary, for example, to limit the temporal * latency of a variable bitrate stream.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-put_page"><a href="#val-put_page" class="anchor"></a><code><span><span class="keyword">val</span> put_page : <span><a href="#type-stream">stream</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Page/index.html#type-t">Page.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>* This function adds a complete page to the bitstream. * * In a typical decoding situation, this function would be called after * using <code>Sync.read</code> to create a valid <code>Page.t</code> * * Raises <code>Bad_data</code> if the serial number of the page did not match the * serial number of the bitstream, or the page version was incorrect.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_packet"><a href="#val-get_packet" class="anchor"></a><code><span><span class="keyword">val</span> get_packet : <span><a href="#type-stream">stream</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-packet">packet</a></span></code></div><div class="spec-doc"><p>* This function assembles a data packet for output * to the codec decoding engine. * * Each successive call returns the next complete packet built from those segments. * In a typical decoding situation, this should be used after calling * <code>put_page</code> to submit a page of data to the bitstream. * * This function should *not* be used. Because of ocaml's paradigm, it is necessary * to copy each packet since they are only valid until this function is called again. * When dealing with many packets, this will lead to multiple unecessary memory allocation * and desallocation. * * Raises <code>Not_enough_data</code> if more data is needed and another page should be submitted. * * Raises <code>Out_of_sync</code> if we are out of sync and there is a gap in the data.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-peek_packet"><a href="#val-peek_packet" class="anchor"></a><code><span><span class="keyword">val</span> peek_packet : <span><a href="#type-stream">stream</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-packet">packet</a></span></code></div><div class="spec-doc"><p>* This function assembles a data packet for output * to the codec decoding engine without advancing the stream. * * Raises <code>Not_enough_data</code> if more data is needed and another page should be submitted. * * Raises <code>Out_of_sync</code> if we are out of sync and there is a gap in the data</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-peek_granulepos"><a href="#val-peek_granulepos" class="anchor"></a><code><span><span class="keyword">val</span> peek_granulepos : <span><a href="#type-stream">stream</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Stdlib</span>.Int64.t</span></code></div><div class="spec-doc"><p>This function picks up the granule position * of the next packet in the stream without advancing it. * * Raises <code>Not_enough_data</code> if more data is needed and another page should be submitted. * * Raises <code>Out_of_sync</code> if we are out of sync and there is a gap in the data</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-skip_packet"><a href="#val-skip_packet" class="anchor"></a><code><span><span class="keyword">val</span> skip_packet : <span><a href="#type-stream">stream</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>This function discards the next packet in the stream. * * Raises <code>Not_enough_data</code> if more data is needed and another page should be submitted. * * Raises <code>Out_of_sync</code> if we are out of sync and there is a gap in the data</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-put_packet"><a href="#val-put_packet" class="anchor"></a><code><span><span class="keyword">val</span> put_packet : <span><a href="#type-stream">stream</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-packet">packet</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>* This function submits a packet to the bitstream for page encapsulation. * After this is called, more packets can be submitted, or pages can be written out. * * This function is provided to ease ogg strea multiplexing, where packet submission * order is important. It should not be used to encoder further data.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-flush_page"><a href="#val-flush_page" class="anchor"></a><code><span><span class="keyword">val</span> flush_page : <span><a href="#type-stream">stream</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Page/index.html#type-t">Page.t</a></span></code></div><div class="spec-doc"><p>* This function checks for remaining packets inside the stream and forces * remaining packets into a page, regardless of the size of the page. * * This should only be used when you want to flush an undersized page from the * middle of the stream. Otherwise, <code>get_page</code> should always be used. * * This function can be used to verify that all packets have been flushed. * * Raises <code>Not_enough_data</code> if all packet data has already been flushed into pages, * and there are no packets to put into the page.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-packet_granulepos"><a href="#val-packet_granulepos" class="anchor"></a><code><span><span class="keyword">val</span> packet_granulepos : <span><a href="#type-packet">packet</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Stdlib</span>.Int64.t</span></code></div><div class="spec-doc"><p>Returns a packet's granule position.</p></div></div></div></body></html>
